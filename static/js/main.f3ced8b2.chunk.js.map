{"version":3,"sources":["data/map/surfaceObjects.js","components/Map/SurfaceObjectsPanel.js","components/Map/MapFileHandler.js","components/Map/Map.js","components/Map/TileSelector.js","components/Map/SurfaceObjectSelector.js","components/Map/MapEditor.js","Simulation Logic/grid.js","Simulation Logic/helpers/movement.js","Simulation Logic/pathfinding.js","Simulation Logic/helpers/hunger.js","Simulation Logic/helpers/food.js","Simulation Logic/update.js","Simulation Logic/helpers/health.js","Simulation Logic/helpers/brain.js","components/Simulation/Simulation.js","data/map/map1preset.js","App.js","index.js"],"names":["tree","color","type","size","movementSpeed","bush","rabbit","maxHealth","wolf","returnSurfaceObject","SurfaceObjectsPanel","brainCopy","surfaceObjects","setSelectedSurfaceObjectId","selectedSurfaceObjectId","brain","surfaceObjCopy","undefined","brainSurfaceObjects","i","brainN","findIndex","x","surfaceObjectId","push","length","className","map","object","key","id","onClick","Number","toFixed","y","health","hunger","action","MapFileHandler","mapSaveNumber","saveData","mapData","surfaceData","brainDataString","JSON","stringify","saveDataString","window","localStorage","setItem","surfObjCopy","brainObj","isMoving","movement","distanceToPoint","directionX","directionY","startX","startY","endX","endY","generateAI","alert","Map","updateMapWithSelectedTile","startClicked","started","isEditor","selectedMapSaveNumber","backClicked","useState","toggleBorder","setToggleBorder","columnWidths","Array","fill","rowHeights","renderSurfaceObjects","col","row","matchingSurfaceObjects","temp","strX","String","Math","round","strY","xIndex","substring","yIndex","fetchSurfaceObjectsForTile","xToStr","yToStr","slice","fetchedObject","cx","cy","r","Cell","columnIndex","rowIndex","style","e","preventDefault","columnCount","columnWidth","index","height","rowCount","rowHeight","width","TileSelector","updateSelectedTileType","selectedTile","SurfaceObjectSelector","updateSelectedSurfaceObjectType","MapEditor","setMap","setSelectedTile","selectedTileType","setSelectedTileType","setSurfaceObjects","setSelectedMapSaveNumber","isDeleting","setIsDeleting","generateWorld","inputSize","newMap","columns","j","defaultTile","generateMap","newSurfaceObjects","generateSurfaceObjects","number","hasOwnProperty","value","data","parse","getItem","editMapClicked","confirm","removeItem","location","reload","sizePrompt","prompt","parsedSize","parseInt","generateMapClicked","TileX","target","nativeEvent","offsetX","offsetY","radius","pow","selectedRemoved","deleteSurfaceObject","newObj","objData","food","ndarray","require","createPlanner","grid","planner","getGrid","k","xSym","ySym","set","setupNdGrid","getPlanner","setupPlanner","getNearbyPointThatIsntWall","counter","validPoint","get","getDistanceToPoint","destX","destY","hypot","initPathfinding","obj","path","self","fixedPath","search","parsedX","parsedY","startSearch","nextPoint","shift","surfaceObject","updateHunger","amount","updateFood","nonBrainObjectUpdate","secondsPassed","update","plantFoodTickUpdate","updateSurfaceObjects","mapCopy","surfaceObjectsPreUpdate","brainPreUpdate","brainUpdate","arr","loseHungerOverTime","leftRange","rightRange","upperRange","bottomRange","randomX","randomY","floor","random","randomPoint","updatedData","nearbyValidPoint","targetAction","direction","distance","getDirectionToPoint","splice","deleteBrainObjById","depletedBushes","bushes","filter","closestBushDistance","closestBush","Date","now","timestamp","distFromBush","getClosestBush","closestPoint","z","Simulation","isLoaded","setIsLoaded","setStarted","requestAnimationFrameID","setRequestAnimationFrameID","setBrain","oldTimeStamp","loadMapClicked","aiData","cancelAnimationFrame","startLoop","requestAnimationFrame","gameLoop","timeStamp","min","Map1","Map2","Map1Ai","Map2Ai","App","selectedNavItem","setSelectedNavItem","navButtonClicked","routeName","useEffect","pathname","toString","toLowerCase","to","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.f3ced8b2.chunk.js","sourcesContent":["\r\nconst tree = {\r\n    color: \"#265031\",\r\n    type: 'tree',\r\n    size: 30,\r\n    movementSpeed: 0\r\n}\r\n\r\nconst bush = {\r\n    color: \"#1fcb72\",\r\n    type: 'bush',\r\n    size: 10,\r\n    movementSpeed: 0\r\n}\r\n\r\nconst rabbit = {\r\n    color: \"#f7e1da\",\r\n    type: 'rabbit',\r\n    size: 15,\r\n    movementSpeed: 75,\r\n    maxHealth: 40,\r\n}\r\n\r\nconst wolf = {\r\n    color: \"#FAD7A0\",\r\n    type: 'wolf',\r\n    size: 25,\r\n    movementSpeed: 70,\r\n    maxHealth: 60,\r\n}\r\n\r\n\r\nexport function returnSurfaceObject(type){\r\n    switch(type){\r\n        case \"tree\":\r\n            return tree;\r\n        case \"bush\":\r\n            return bush;\r\n        case \"rabbit\":\r\n            return rabbit;\r\n        case \"wolf\":\r\n            return wolf;\r\n        default:\r\n            return tree;\r\n    }\r\n}","import React from 'react';\r\n\r\nfunction SurfaceObjectsPanel({surfaceObjects, setSelectedSurfaceObjectId, selectedSurfaceObjectId, brain}) {\r\n\r\n    function panelClicked(id){\r\n        if(selectedSurfaceObjectId === id){\r\n            //deselect\r\n            setSelectedSurfaceObjectId(-1);\r\n        }else{\r\n            setSelectedSurfaceObjectId(id);\r\n        }\r\n    }\r\n\r\n    let surfaceObjCopy = [...surfaceObjects];\r\n\r\n    let brainCopy;\r\n\r\n    if(brain !== undefined){\r\n        brainCopy = [...brain];\r\n    }\r\n\r\n    let brainSurfaceObjects = [];\r\n    for(let i = 0; i < surfaceObjCopy.length; i++){\r\n        if(surfaceObjCopy[i].type === 'rabbit'){\r\n            if(brain !== undefined){\r\n                let brainN = brainCopy[brain.findIndex(x => x.surfaceObjectId === i)];\r\n                brainSurfaceObjects.push([surfaceObjCopy[i], brainN]);\r\n            }else{\r\n                brainSurfaceObjects.push([surfaceObjCopy[i], 0]);\r\n            }\r\n        }\r\n    }\r\n\r\n    return(\r\n        <div className=\"SurfaceObjectsPanels\">\r\n            {brainSurfaceObjects.map((object, i) => {\r\n                    \r\n                    return(\r\n                        <div key={object[0].id} onClick={() => panelClicked(object[0].id)}>\r\n                            <ul className={\"panelList Tile-Selector\" + (selectedSurfaceObjectId === object[0].id ? ' selectedButton' : ' ')}>\r\n                                <li className=\"listItem\">id: {object[0].id}</li>\r\n                                <li className=\"listItem\">type: {object[0].type}</li>\r\n                                <li className=\"listItem\">x: {Number(object[0].x).toFixed(2)}    y: {Number(object[0].y).toFixed(2)}</li>\r\n                                <li className=\"listItem\">health: {Number(object[0].health).toFixed(2)}</li>\r\n                                <li className=\"listItem\">hunger: {Number(object[0].hunger).toFixed(2)}</li>\r\n\r\n                                {brain !== undefined && object[1] !== undefined &&\r\n                                    <li className=\"listItem\">action: {object[1].action}</li>\r\n                                }\r\n                            </ul>\r\n                        </div>\r\n                    )\r\n                    \r\n            })}\r\n        </div>\r\n    );\r\n    \r\n}\r\n\r\nexport default SurfaceObjectsPanel;\r\n","import React from 'react';\r\n\r\nfunction MapFileHandler({map, surfaceObjects, mapSaveNumber, brain}) {\r\n\r\n\r\n    function generateAI(){\r\n        let brain = [];\r\n        \r\n        let surfObjCopy = [...surfaceObjects];\r\n\r\n        for(let i = 0; i < surfObjCopy.length; i++){\r\n\r\n            let linkedId = surfObjCopy[i].id;\r\n\r\n            let brainObj = {\r\n                surfaceObjectId: linkedId,\r\n                isMoving: false,\r\n                action: 'Idle',\r\n                movement: {\r\n                    distanceToPoint: '',\r\n                    directionX: '',\r\n                    directionY: '',\r\n                    startX: 0,\r\n                    startY: 0,\r\n                    endX: 0,\r\n                    endY: 0,\r\n                }\r\n            }\r\n\r\n            brain.push(brainObj);\r\n        }\r\n\r\n        return JSON.stringify(brain);\r\n\r\n    }\r\n\r\n    function mapExport(){\r\n        let mapCopy = [...map];\r\n        let surfaceObjectsCopy = [...surfaceObjects];\r\n        let saveData = {mapData: mapCopy, surfaceData: surfaceObjectsCopy};\r\n        let brainDataString = JSON.stringify(brain);\r\n        let saveDataString = JSON.stringify(saveData);\r\n        \r\n        window.localStorage.setItem(`map${mapSaveNumber}`, saveDataString);\r\n\r\n        if(brain === undefined){\r\n            window.localStorage.setItem(`map${mapSaveNumber}Ai`, generateAI());\r\n        }else{\r\n            window.localStorage.setItem(`map${mapSaveNumber}Ai`, brainDataString);\r\n        }\r\n        \r\n        alert(\"Map saved\");\r\n        \r\n    }\r\n\r\n\r\n    return(\r\n        <button className=\"navBtn inputButtonNoBorder Tile-Selector\" onClick={mapExport}>Save Map</button>\r\n    );\r\n    \r\n}\r\n\r\nexport default MapFileHandler;\r\n","import React, {useState} from 'react';\r\nimport './Map.css';\r\nimport { VariableSizeGrid as Grid } from 'react-window';\r\nimport {returnSurfaceObject} from '../../data/map/surfaceObjects'\r\nimport SurfaceObjectsPanel from './SurfaceObjectsPanel';\r\nimport MapFileHandler from './MapFileHandler';\r\n\r\nfunction Map({map, surfaceObjects, updateMapWithSelectedTile, startClicked, started, isEditor, brain, selectedMapSaveNumber, backClicked}) {\r\n\r\n    const [toggleBorder, setToggleBorder] = useState(false);\r\n    const [selectedSurfaceObjectId, setSelectedSurfaceObjectId] = useState(-1);\r\n\r\n    function toggleCellBorders(e){\r\n        e.preventDefault();\r\n        setToggleBorder(!toggleBorder);\r\n    }\r\n\r\n    const columnWidths = new Array(map.length)\r\n        .fill(true)\r\n        .map(() => 100);\r\n\r\n    const rowHeights = new Array(map.length)\r\n        .fill(true)\r\n        .map(() => 100);\r\n\r\n    //creates an array of the surfaceObjects that exist in tile at col, row\r\n    function fetchSurfaceObjectsForTile(col, row){\r\n        let temp = [];\r\n        for(let i = 0; i < surfaceObjects.length; i++){\r\n            //have to round since you cant have decimal co-ordinates\r\n            let strX = String(Math.round(surfaceObjects[i].x));\r\n            let strY = String(Math.round(surfaceObjects[i].y));\r\n            //fix if [0][y] or [x][0]\r\n            if(strX.length <= 2){\r\n                strX = \"0\" + strX;\r\n            }\r\n            if(strY.length <= 2){\r\n                strY = \"0\" + strY;\r\n            }\r\n\r\n            //fetch only the coords for col/row. last two digits are internal svg coords\r\n            let xIndex = strX.substring(0, strX.length - 2);\r\n            let yIndex = strY.substring(0, strY.length - 2);\r\n            //have to check if x or y is not a \r\n            \r\n            if(Number(xIndex) === col && Number(yIndex) === row){\r\n                temp.push(surfaceObjects[i]);\r\n            }\r\n        }\r\n        return temp;\r\n    }\r\n\r\n\r\n    function renderSurfaceObjects(col, row){\r\n        let matchingSurfaceObjects = fetchSurfaceObjectsForTile(col, row); \r\n        if(matchingSurfaceObjects.length > 0){\r\n            //console.log(matchingSurfaceObjects);\r\n        }\r\n        return(\r\n            <svg className=\"svg\">\r\n                {matchingSurfaceObjects.map((object, i) => {\r\n                    let xToStr = String(Math.round(object.x));\r\n                    let yToStr = String(Math.round(object.y));\r\n                    if(xToStr.length <= 2){\r\n                        xToStr = \"0\" + xToStr;\r\n                    }\r\n                    if(yToStr.length <= 2){\r\n                        yToStr = \"0\" + yToStr;\r\n                    }\r\n\r\n                    //since x,y are ints, cast to string and get the last two indexes\r\n                    //since the begining index's are the tile's index\r\n                    let x = xToStr.slice(-2);\r\n                    let y = yToStr.slice(-2);\r\n                    let fetchedObject = returnSurfaceObject(object.type);\r\n\r\n                    let key = xToStr + \",\" + yToStr + \",\" + object.id;\r\n                    \r\n                    return(\r\n                        <circle className={fetchedObject.type + \" \" + (selectedSurfaceObjectId === object.id ? \"cell-border\" : \"no-border\")} key={key} cx={x} cy={y} r={fetchedObject.size} fill={fetchedObject.color}>\r\n                        </circle>\r\n                    )\r\n                    \r\n                })}\r\n            </svg>\r\n        );\r\n    }\r\n\r\n    const Cell = ({ columnIndex, rowIndex, style }) => (\r\n        <div\r\n            style={style}\r\n            className={map[rowIndex][columnIndex].type + \" \" + (toggleBorder ? \"cell-border\" : \"no-border\") + \" Cell\"}\r\n            onClick={(e) => updateMapWithSelectedTile(e, map[rowIndex][columnIndex].x, map[rowIndex][columnIndex].y)}\r\n        >\r\n            {renderSurfaceObjects(columnIndex, rowIndex)}\r\n            \r\n        </div>\r\n    );\r\n\r\n\r\n    if (!(typeof updateMapWithSelectedTile === \"function\")) { \r\n        updateMapWithSelectedTile = function(){}\r\n    }\r\n\r\n    return (\r\n        <div className=\"Map\">\r\n            <div className=\"leftContainer\">\r\n                <div className=\"mapControls\">\r\n                    <div className={\"mapSaveFileText smallerdisplay\"}>Map{\" \" + selectedMapSaveNumber}</div>\r\n                    <button className={\"navBtn inputButtonNoBorder Tile-Selector\"} onClick={backClicked}>{\"Back\"}</button>\r\n                    <MapFileHandler brain={brain} map={map} surfaceObjects={surfaceObjects} mapSaveNumber={selectedMapSaveNumber}/>\r\n                    {!isEditor ? (\r\n                        <button className={\"navBtn inputButtonNoBorder Tile-Selector\" + (started ? ' selectedButton' : ' ')} onClick={startClicked}>{started ? \"Stop\" : \"Start\"}</button>\r\n                    ):(<></>)\r\n                    }\r\n                    <button className={\"navBtn inputButtonNoBorder Tile-Selector\" + (toggleBorder ? ' selectedButton' : ' ')} onClick={toggleCellBorders}>Toggle Cell Borders</button>\r\n                </div>\r\n\r\n                <SurfaceObjectsPanel\r\n                    surfaceObjects={surfaceObjects}\r\n                    brain={brain}\r\n                    setSelectedSurfaceObjectId={setSelectedSurfaceObjectId}\r\n                    selectedSurfaceObjectId={selectedSurfaceObjectId}\r\n                />\r\n\r\n            </div>\r\n            \r\n            \r\n            <div className=\"mapContainer\">\r\n                <>\r\n                    <Grid\r\n                        className=\"Grid\"\r\n                        columnCount={map.length}\r\n                        columnWidth={index => columnWidths[index]}\r\n                        height={750}\r\n                        rowCount={map.length}\r\n                        rowHeight={index => rowHeights[index]}\r\n                        width={1000}\r\n                        >\r\n                            {Cell}\r\n                    </Grid>\r\n                </>\r\n            </div>           \r\n        </div>\r\n    );\r\n}\r\n\r\nexport default Map;\r\n","import React from 'react';\r\n\r\nfunction TileSelector({updateSelectedTileType, selectedTile}) {\r\n\r\n    return(\r\n        <div className=\"Tile-Selector\">\r\n            <button className={\"navBtn inputButtonNoBorder\" + (selectedTile === 'grass' ? ' selectedButton' : ' ')} onClick={() => updateSelectedTileType('grass')}>Grass</button>\r\n            <button className={\"navBtn inputButtonNoBorder\" + (selectedTile === 'dirt' ? ' selectedButton' : ' ')} onClick={() => updateSelectedTileType('dirt')}>Dirt</button>\r\n            <button className={\"navBtn inputButtonNoBorder\" + (selectedTile === 'rock' ? ' selectedButton' : ' ')} onClick={() => updateSelectedTileType('rock')}>Rock</button>\r\n            <button className={\"navBtn inputButtonNoBorder\" + (selectedTile === 'water' ? ' selectedButton' : ' ')} onClick={() => updateSelectedTileType('water')}>Water</button>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default TileSelector;\r\n","import React from 'react';\r\n\r\nfunction SurfaceObjectSelector({updateSelectedSurfaceObjectType, selectedTile}) {\r\n\r\n    return(\r\n        <div className=\"Tile-Selector\">\r\n            <button className={\"navBtn inputButtonNoBorder\"  + (selectedTile === 'tree' ? ' selectedButton' : ' ')} onClick={() => updateSelectedSurfaceObjectType('tree')}>Tree</button>\r\n            <button className={\"navBtn inputButtonNoBorder\"  + (selectedTile === 'bush' ? ' selectedButton' : ' ')} onClick={() => updateSelectedSurfaceObjectType('bush')}>Bush</button>\r\n            <button className={\"navBtn inputButtonNoBorder\"  + (selectedTile === 'rabbit' ? ' selectedButton' : ' ')} onClick={() => updateSelectedSurfaceObjectType('rabbit')}>Rabbit</button>\r\n        </div>\r\n    );\r\n\r\n}\r\n\r\nexport default SurfaceObjectSelector;\r\n","import React, { useState } from 'react';\r\nimport Map from './Map';\r\nimport TileSelector from './TileSelector';\r\nimport SurfaceObjectSelector from './SurfaceObjectSelector';\r\nimport { returnSurfaceObject } from '../../data/map/surfaceObjects';\r\n\r\nfunction MapEditor() {\r\n\r\n    const [map, setMap] = useState([]);\r\n    const [selectedTile, setSelectedTile] = useState('grass');\r\n    const [selectedTileType, setSelectedTileType] = useState('');\r\n    const [surfaceObjects, setSurfaceObjects] = useState([]);\r\n    const [selectedMapSaveNumber, setSelectedMapSaveNumber] = useState(0);\r\n    const [isDeleting, setIsDeleting] = useState(false);\r\n\r\n    function generateSurfaceObjects(){\r\n        \r\n        let newSurfaceObjects = [];\r\n        setSurfaceObjects(surfaceObjects => (newSurfaceObjects));\r\n        \r\n    }\r\n\r\n    //generateMap from mapSize args\r\n    function generateMap(inputSize){\r\n\r\n        let newMap = [];\r\n\r\n        for(let i = 0; i < inputSize; i++){\r\n            let columns = [];\r\n            for(let j = 0; j < inputSize; j++){\r\n                let defaultTile = {\r\n                    x: i,\r\n                    y: j,\r\n                    type: \"grass\",\r\n                }; \r\n                columns.push(defaultTile);\r\n            }\r\n            newMap.push(columns);  \r\n        }\r\n\r\n        setMap(map => (newMap));\r\n    };\r\n\r\n    function generateWorld(inputSize){\r\n        generateMap(inputSize);\r\n        generateSurfaceObjects();\r\n    }\r\n\r\n    function updateSelectedTileType(type){\r\n        setSelectedTile(type);\r\n        setSelectedTileType('map');\r\n    } \r\n\r\n\r\n    function updateSelectedSurfaceObjectType(type){\r\n        setSelectedTile(type);\r\n        setSelectedTileType('surface');\r\n    }\r\n\r\n    function deleteSurfaceObjectClicked(){\r\n        setIsDeleting(!isDeleting);\r\n    }\r\n\r\n    function deleteSurfaceObject(e, x, y){\r\n        let TileX = (x * 100);\r\n        let TileY = (y * 100);\r\n        let xOffset = (e.nativeEvent.offsetX);\r\n        let yOffset = (e.nativeEvent.offsetY);\r\n\r\n        let CalcX = (TileY) + (xOffset);\r\n        let CalcY = (TileX) + (yOffset);\r\n\r\n        let target = {\r\n            x: CalcX,\r\n            y: CalcY\r\n        }\r\n        //now we need to find the surfaceObject that intersects with this one.\r\n        for(let i = 0; i < surfaceObjects.length; i++){\r\n            let radius = returnSurfaceObject(surfaceObjects[i].type).size;\r\n            //point is inside of surfaceObject if true\r\n            if(Math.pow(target.x - surfaceObjects[i].x, 2) + Math.pow(target.y - surfaceObjects[i].y, 2) < Math.pow(radius, 2)){\r\n                //remove surfaceObject from array without mutating\r\n                const selectedRemoved = [...surfaceObjects.slice(0, i), ...surfaceObjects.slice(i + 1)];\r\n                setSurfaceObjects(selectedRemoved);\r\n            } \r\n               \r\n        }\r\n            \r\n    }\r\n\r\n    function updateMapWithSelectedTile(e, x, y){\r\n        if(isDeleting){\r\n            deleteSurfaceObject(e, x, y);\r\n        }else{\r\n            if(selectedTileType === 'map'){\r\n                let newMap = [...map];\r\n                newMap[x][y].type = selectedTile;\r\n                setMap(map => (newMap));\r\n            }\r\n            if(selectedTileType === 'surface'){\r\n                let newSurfaceObjects = [...surfaceObjects];\r\n                let TileX = (x * 100);\r\n                let TileY = (y * 100);\r\n                let xOffset = (e.nativeEvent.offsetX);\r\n                let yOffset = (e.nativeEvent.offsetY);\r\n    \r\n                let CalcX = (TileY) + (xOffset);\r\n                let CalcY = (TileX) + (yOffset);\r\n    \r\n                //x y have to be flipped for svg\r\n                let newObj = {\r\n                    x: CalcX,\r\n                    y: CalcY,\r\n                }\r\n    \r\n                let objData = returnSurfaceObject(selectedTile);\r\n                \r\n                newObj.health = objData.maxHealth;\r\n    \r\n                if(objData.type === 'rabbit'){\r\n                    newObj.hunger = 100;\r\n                }\r\n    \r\n                if(objData.type === 'bush'){\r\n                    newObj.food = 100;\r\n                }\r\n    \r\n                newObj.type = objData.type;\r\n    \r\n                newObj.id = newSurfaceObjects.length;\r\n                newSurfaceObjects.push(newObj);\r\n\r\n                setSurfaceObjects(surfaceObjects => (newSurfaceObjects));\r\n            }\r\n        }\r\n    }\r\n    \r\n    function editMapClicked(mapSaveNumber){\r\n        setSelectedMapSaveNumber(mapSaveNumber);\r\n\r\n        let data = JSON.parse(window.localStorage.getItem(`map${mapSaveNumber}`));\r\n        setMap(map => (data.mapData));\r\n        setSurfaceObjects(surfaceObjects => (data.surfaceData));\r\n    }\r\n\r\n    function generateMapClicked(mapSaveNumber){\r\n\r\n        setSelectedMapSaveNumber(mapSaveNumber);\r\n\r\n        let sizePrompt = prompt(\"Enter a map size as an integer between 1 - 6:\");\r\n        if (sizePrompt === null || sizePrompt === \"\") {\r\n            alert(\"Invalid map size, please enter a integer between 1-6\");\r\n            return;\r\n        } else {\r\n            let parsedSize = parseInt(sizePrompt);\r\n\r\n            if(!(parsedSize > 0 && parsedSize < 7)){\r\n                alert(\"Invalid map size, please enter a integer between 1-6\");\r\n                return;\r\n            }\r\n            generateWorld(parsedSize);\r\n        } \r\n    }\r\n\r\n    function deleteMapClicked(mapSaveNumber){\r\n        if(window.confirm(`Are you sure you want to delete save #${mapSaveNumber}`)) {\r\n            localStorage.removeItem(`map${mapSaveNumber}`);\r\n            localStorage.removeItem(`map${mapSaveNumber}Ai`);\r\n            window.location.reload();\r\n        }\r\n    }\r\n    \r\n\r\n    function loadLocalSaves(){\r\n\r\n        //this is the amount of saves we are supporting right now\r\n        const numbers = [1, 2, 3, 4, 5];\r\n\r\n        return numbers.map((number) => \r\n            <div key={number} className=\"saveBar\">\r\n                \r\n                <p className=\"mapSaveFileText\">Map {number}</p>\r\n\r\n                {localStorage.hasOwnProperty(`map${number}`) ? (\r\n                    <div className=\"saveControls\">\r\n                        <input type=\"button\" value=\"Edit\" className=\"navBtn inputButtonNoBorder\" onClick={() => editMapClicked(number)}></input>\r\n                        <input type=\"button\" value=\"Delete\" className=\"navBtn inputButtonNoBorder\" onClick={() => deleteMapClicked(number)}></input>\r\n                    </div>\r\n                ) \r\n                :\r\n                (\r\n                    <div className=\"saveControls\">\r\n                        <input type=\"button\" value=\"Generate\" className=\"navBtn inputButtonNoBorder\" onClick={() => generateMapClicked(number)}></input>\r\n                    </div>\r\n                )}\r\n\r\n            </div>\r\n\r\n                \r\n            \r\n        );\r\n    }\r\n\r\n    function backClicked(){\r\n        setMap([]);\r\n    }\r\n  \r\n    return (\r\n        <div className = \"Map-Editor\"> \r\n            {map.length === 0 ? (\r\n                <div className=\"preEditor\">\r\n                    <div className=\"preLoad\">\r\n                        <p className=\"mapSaveFileText centeredText\" >Map Editor</p>\r\n                        {loadLocalSaves()}\r\n                    </div>\r\n                </div>\r\n                \r\n            ) : (\r\n                <>  \r\n                    <div className=\"topBar\">\r\n                        <div className=\"editorControls\">\r\n                            <TileSelector selectedTile={selectedTile} updateSelectedTileType={updateSelectedTileType}/>\r\n                            <SurfaceObjectSelector selectedTile={selectedTile} updateSelectedSurfaceObjectType={updateSelectedSurfaceObjectType}></SurfaceObjectSelector>\r\n                            <button className={\"navBtn inputButtonNoBorder Tile-Selector\"  + (isDeleting ? ' selectedButton' : ' ')} onClick={deleteSurfaceObjectClicked}>{\"Delete\"}</button>\r\n                        </div>\r\n                    </div>\r\n                    \r\n                    <Map map={map}\r\n                        backClicked={backClicked}\r\n                        surfaceObjects={surfaceObjects}\r\n                        isEditor={true}\r\n                        selectedMapSaveNumber={selectedMapSaveNumber}\r\n                        updateMapWithSelectedTile={updateMapWithSelectedTile}\r\n                    />\r\n                </>\r\n            )}\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default MapEditor;\r\n","import { returnSurfaceObject } from '../data/map/surfaceObjects';\r\n\r\nlet ndarray = require('ndarray');\r\nlet createPlanner = require('l1-path-finder');\r\n\r\nlet grid = [];\r\n\r\nlet planner = 0;\r\n\r\nexport function getGrid(map, surfaceObjects){\r\n\r\n    //I wonder if this will create a new grid, if we have a grid loaded from one map,\r\n    //and then load into a different map in the same session. \r\n    if(grid.length === 0){\r\n        grid = setupNdGrid(map, surfaceObjects);\r\n        return grid;\r\n    }else{\r\n        return grid;\r\n    }\r\n}\r\n\r\nexport function getPlanner(map, surfaceObjects){\r\n    if(planner === 0){\r\n        planner = setupPlanner(map, surfaceObjects);\r\n        return planner;\r\n    }else{\r\n        return planner;\r\n    }\r\n}  \r\n\r\n//checks if surface object is at this point, will its bounds collide with anything\r\nexport function isPointInBounds(surfaceObjectId, point, surfaceObjects){\r\n\r\n    let surfaceObj;\r\n    for(let n = 0; n < surfaceObjects.length; n++){\r\n        if(surfaceObjects[n].id === surfaceObjectId){\r\n            surfaceObj = surfaceObjects[n];\r\n        }\r\n    }\r\n\r\n    let radius = returnSurfaceObject(surfaceObj.type).size;\r\n\r\n    for (let i = point.x - radius ; i <= point.x; i++){\r\n        for (let j = point.y - radius ; j <= point.y; j++){\r\n            if ((i - point.x)*(i - point.x) + (j - point.y)*(j - point.y) <= radius*radius){\r\n                let xSym = point.x - (i - point.x);\r\n                let ySym = point.y - (j - point.y);\r\n                // (x, y), (x, ySym), (xSym , y), (xSym, ySym) are in the circle                \r\n                if(grid.get(i, j) === 1){\r\n                    return true;\r\n                }\r\n\r\n                if(grid.get(i, ySym) === 1){\r\n                    return true;\r\n                }\r\n\r\n                if(grid.get(xSym, j) === 1){\r\n                    return true;\r\n                }\r\n\r\n                if(grid.get(xSym, ySym) === 1){\r\n                    return true;\r\n                }\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nfunction setupPlanner(map, surfaceObjects){\r\n    //Create path planner\r\n    planner = createPlanner(getGrid(map, surfaceObjects));\r\n    return planner;\r\n}\r\n\r\nexport function getGridElementAtKey(x, y){\r\n    return grid.get(Math.round(x), Math.round(y))\r\n}\r\n\r\nexport function getNearbyPointThatIsntWall(x, y){\r\n    x = Math.round(x);\r\n    y = Math.round(y);\r\n    //console.log(`grid get at x: ${x} y: ${y} = ` + grid.get(x, y));\r\n    let counter = 0;\r\n    let validPoint = 0;\r\n    while(validPoint === 0){\r\n        if(grid.get(x + counter, y + counter) === 0){\r\n            validPoint = {x: x + counter, y: y + counter};\r\n            break;\r\n        }\r\n        if(grid.get(x - counter, y - counter) === 0){\r\n            validPoint = {x: x - counter, y: y - counter};\r\n            break;\r\n        }\r\n        if(grid.get(x + counter, y - counter) === 0){\r\n            validPoint = {x: x + counter, y: y - counter};\r\n            break;\r\n        }\r\n        if(grid.get(x - counter, y + counter) === 0){\r\n            validPoint = {x: x - counter, y: y + counter};\r\n            break;\r\n        }\r\n        counter += 1;\r\n    }\r\n\r\n    return validPoint;\r\n}\r\n\r\n\r\nfunction setupNdGrid(map, surfaceObjects){\r\n    let size = (map.length * 100) * (map.length * 100);\r\n    //fill with 0s\r\n    for(let i = 0; i < size; i++){\r\n        grid[i] = 0;\r\n    }\r\n\r\n    //Create a maze as an ndarray\r\n    grid = ndarray(grid, [map.length * 100, map.length * 100])\r\n    \r\n    for(let k = 0; k < surfaceObjects.length; k++){\r\n        let fetchedData = returnSurfaceObject(surfaceObjects[k].type);\r\n        let radius = fetchedData.size;\r\n        //if tree then set as wall\r\n        if(surfaceObjects[k].type === \"tree\"){\r\n            for (let i = surfaceObjects[k].x - radius ; i <= surfaceObjects[k].x; i++){\r\n                for (let j = surfaceObjects[k].y - radius ; j <= surfaceObjects[k].y; j++){\r\n                    if ((i - surfaceObjects[k].x)*(i - surfaceObjects[k].x) + (j - surfaceObjects[k].y)*(j - surfaceObjects[k].y) <= radius*radius){\r\n                        let xSym = surfaceObjects[k].x - (i - surfaceObjects[k].x);\r\n                        let ySym = surfaceObjects[k].y - (j - surfaceObjects[k].y);\r\n                        // (x, y), (x, ySym), (xSym , y), (xSym, ySym) are in the circle\r\n                        grid.set(i,j, 1);\r\n                        grid.set(i,ySym, 1);\r\n                        grid.set(xSym, j, 1);\r\n                        grid.set(xSym, ySym, 1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return grid;\r\n}\r\n","import { startSearch } from '../pathfinding';\r\n\r\nexport function getDistanceToPoint(x, y, destX, destY){\r\n    let distance = Math.hypot(destX - x, destY - y);\r\n    return distance;\r\n}\r\n\r\nexport function getDirectionToPoint(x, y, destX, destY, distance){\r\n\r\n    let xDir = (destX - x) / distance\r\n    let yDir = (destY - y) / distance\r\n    \r\n    return {x: xDir, y: yDir};\r\n}\r\n\r\n//modifies the objects properties so its ready for pathfinding.\r\n//creates a new path to destination for obj, and sets state it needs to start the \"Moving\" action\r\n//takes surfaceObject and brainObject\r\nexport function initPathfinding(obj, brainN, target, map, surfaceObjects, grid){\r\n\r\n    brainN.path = startSearch(obj, target, map, surfaceObjects, grid);\r\n\r\n    if(!brainN.path){\r\n        return false;\r\n    }\r\n\r\n    \r\n    let nextPoint = brainN.path.shift();\r\n    //need to skip first point\r\n    nextPoint = brainN.path.shift();\r\n    if(nextPoint === undefined){\r\n        return false;\r\n    }else{\r\n        //set endX and endY to the x and y from this\r\n        brainN.movement.endX = nextPoint.x;\r\n        brainN.movement.endY = nextPoint.y;\r\n        brainN.movement.startX = obj.x;\r\n        brainN.movement.startY = obj.y;\r\n    }\r\n\r\n    return {surfaceObject: obj, brain: brainN};\r\n}\r\n","import { getPlanner } from './grid';    \r\n\r\nexport function startSearch(self, target, map, surfaceObjects){\r\n    \r\n\r\n    //Find path\r\n    let path = [];\r\n    let planner = getPlanner(map, surfaceObjects);\r\n    let fixedPath = [];\r\n\r\n    planner.search(self.x,self.y,  target.x,target.y, path);\r\n\r\n    //format to {x, y} object\r\n    for(let i = 0; i < path.length; i+= 2){\r\n        let parsedX = path[i];\r\n        let parsedY = path[i+1]; \r\n        fixedPath.push({x: parsedX, y: parsedY});\r\n    }\r\n    \r\n    return fixedPath;\r\n    \r\n}","//takes a surfaceObject and a hunger modifier and returns the object with the property changed\r\nexport function updateHunger(obj, amount){\r\n    obj.hunger = obj.hunger + amount;\r\n\r\n    return obj;\r\n}\r\n\r\n//takes surfaceObject and time elapsed and updates the objects hunger to the amount lost over the secondsPassed\r\nexport function loseHungerOverTime(secondsPassed, obj){\r\n    //where the rate is hunger depletion speed * time elapsed\r\n    // * -1 to make it decrease\r\n    let hungerDepletionAmount = 3 * secondsPassed * - 1;\r\n    obj = updateHunger(obj, hungerDepletionAmount);\r\n    \r\n    return obj;\r\n}\r\n\r\n","import { getDistanceToPoint } from './movement';\r\n\r\n//used for bush food property\r\nexport function updateFood(obj, amount){\r\n    if(obj.food + amount <= 0 ){\r\n        obj.food = 0;\r\n    }else{\r\n        obj.food = obj.food + amount;\r\n    }\r\n\r\n\r\n    return obj;\r\n}\r\n\r\nexport function plantFoodTickUpdate(secondsPassed, obj){\r\n    //where the food tick update rate is food tick rate * time elapsed\r\n    let foodTickRate = 1 * secondsPassed;\r\n    obj = updateFood(obj, foodTickRate);\r\n    \r\n    return obj;\r\n}\r\n\r\n\r\n//where obj is the surfaceObject we are searching from\r\n//returns null if no bush found\r\nexport function getClosestBush(surfaceObjects, obj, brainN){\r\n\r\n    if(brainN.depletedBushes === undefined){\r\n        brainN.depletedBushes = [];\r\n    }\r\n\r\n    let bushes = surfaceObjects.filter(object => object.type === 'bush');\r\n\r\n    //go through each bush\r\n    let closestBushDistance = -1;\r\n    let closestBush = null;\r\n\r\n        for(let i = 0; i < bushes.length; i++){\r\n            \r\n            for(let j = 0; j < brainN.depletedBushes.length; j++){\r\n                if(bushes[i].id === brainN.depletedBushes[j].id){\r\n                    //if it has been depleted for more than 10 seconds we can go back to it again\r\n                    if(Math.floor(Date.now() / 1000) - brainN.depletedBushes[i].timestamp >= 10){\r\n                        //I would update the brainN object but I cannot here because this isnt a brain\r\n                        //modifying function.\r\n                        //this check might be useless since I think I have to make a cleanDepletedBushes() before I call this function\r\n                        //anyways or else deplete bushes will never empty.\r\n                    }else{\r\n                        //skip searching this bush\r\n                    }\r\n                }\r\n            }\r\n\r\n            let distFromBush = getDistanceToPoint(obj.x, obj.y, bushes[i].x, bushes[i].y); \r\n            if(distFromBush < closestBushDistance || closestBushDistance === -1){\r\n                closestBushDistance = distFromBush;\r\n                closestBush = bushes[i];\r\n            }\r\n        }\r\n\r\n    return closestBush;    \r\n    \r\n}","import { getDirectionToPoint, getDistanceToPoint, initPathfinding } from './helpers/movement';\r\nimport { updateHunger, loseHungerOverTime } from './helpers/hunger';\r\nimport { updateFood, plantFoodTickUpdate, getClosestBush } from './helpers/food';\r\nimport { updateHealth } from './helpers/health';\r\nimport { deleteBrainObjById } from './helpers/brain';\r\nimport { returnSurfaceObject } from '../data/map/surfaceObjects';\r\nimport { getGridElementAtKey, getNearbyPointThatIsntWall } from '../Simulation Logic/grid';\r\n\r\n\r\nfunction removeFromArrayByIndex(arr, index){\r\n    arr.splice(index, 1);\r\n    return arr;\r\n}\r\n\r\nfunction nonBrainObjectUpdate(secondsPassed, update, i){\r\n    \r\n    //nested update logic\r\n    if(update.type === 'bush'){\r\n        plantFoodTickUpdate(secondsPassed, update);\r\n    }\r\n\r\n    return update;\r\n\r\n}\r\n\r\n//when refractor-ing add a brainObjectUpdate() \r\nexport function updateSurfaceObjects(secondsPassed, mapCopy, surfaceObjectsPreUpdate, brainPreUpdate, grid){\r\n\r\n    //no surfaceObjects exist\r\n    if(surfaceObjectsPreUpdate.length === undefined){\r\n        return;\r\n    }\r\n\r\n    let update = [...surfaceObjectsPreUpdate];\r\n    let brainUpdate = [...brainPreUpdate];\r\n\r\n    \r\n    for(let i = 0; i < update.length; i++){\r\n\r\n        let brainN = brainUpdate[brainUpdate.findIndex(x => x.surfaceObjectId === update[i].id)];\r\n        //need a bool property for this\r\n        if(update[i].type === 'bush' || update[i].type === 'tree'){\r\n            update[i] = nonBrainObjectUpdate(secondsPassed, update[i], i);\r\n        }else{\r\n\r\n            if((update[i].health <= 0) && brainN.action !== \"Dying\"){\r\n                brainN.action = \"Dying\";\r\n                continue;\r\n            }else{\r\n                //TICK STATUS MODIFIERS\r\n                if(update[i].hunger <= 0 && update[i].health > 0){\r\n                    //starve to death\r\n                    update[i] = updateHealth(update[i], -1);\r\n                    continue;\r\n                }\r\n\r\n                //always loses hunger no matter what\r\n                update[i] = loseHungerOverTime(secondsPassed, update[i]);\r\n\r\n                if(update[i].hunger >= 100){\r\n                    brainN.action = \"Idle\";\r\n                    continue;\r\n                }\r\n\r\n\r\n                //THINKING\r\n                switch (brainN.action){\r\n                    case \"Idle\":\r\n                        if(update[i].hunger <= 50){\r\n                            brainN.action = \"Hungry\";\r\n                            break;\r\n                        }\r\n\r\n                        //default action, pick a random point and move to it.\r\n                        //for wander movement\r\n                        //pick a random point 200px any direction from surface object\r\n                        let leftRange = update[i].x - 200;\r\n                        let rightRange = update[i].x + 200;\r\n                        let upperRange = update[i].y - 200;\r\n                        let bottomRange = update[i].y + 200;\r\n                        \r\n                        let randomX = -1;\r\n                        let randomY = -1;\r\n                        \r\n                        //do it until valid co ords are found\r\n                        //if path is a wall that is ok because this will just run again\r\n                        //the next frame\r\n                        while(randomX < 0 || randomY < 0 || randomX > mapCopy.length * 100 || randomY > mapCopy.length * 100){\r\n                            //in range\r\n                            randomX = Math.floor(Math.random() * (rightRange - leftRange + 1)) + leftRange;\r\n                            randomY = Math.floor(Math.random() * (upperRange - bottomRange + 1)) + bottomRange;\r\n                            if(getGridElementAtKey(randomX, randomY) === 1){\r\n                                randomX = -1;\r\n                            }\r\n                        }\r\n                        \r\n                        let randomPoint = {x: randomX, y: randomY};\r\n                        let updatedData = initPathfinding(update[i], brainN, randomPoint, mapCopy, update, grid);\r\n\r\n                        //no path found, set state to idle\r\n                        if(!updatedData){\r\n                            //console.log(\"idle no path found for, \", brainN.surfaceObjectId);\r\n\r\n                            //need to catch the error for when we are trapped in a tree\r\n                            //we will never make a valid path because update[i] is going to have starting\r\n                            //coords that are a wall.\r\n\r\n                            //need to find a nearby point that is not a wall.\r\n                            let nearbyValidPoint = getNearbyPointThatIsntWall(update[i].x, update[i].y);\r\n                            //reset surfaceObject to this x,y. will be so close usually that you cant tell.\r\n                            update[i].x = nearbyValidPoint.x;\r\n                            update[i].y = nearbyValidPoint.y;\r\n\r\n                            brainN.action = \"Idle\";\r\n                            break;\r\n                        }else{\r\n                            //attach path details to object\r\n                            update[i] = updatedData.surfaceObject;\r\n                            brainN = updatedData.brain;\r\n                            //set to moving, inits action\r\n                            brainN.action = \"Moving\";\r\n                            brainN.targetAction = \"Wander\";\r\n                        }\r\n                        break;\r\n\r\n                    case \"Reached Target\":\r\n                        if(brainN.targetAction === \"Eat\"){\r\n                            brainN.action = \"Eat Target\";\r\n                        }else{\r\n                            brainN.action = \"Idle\";\r\n                        }\r\n\r\n                        break;\r\n                    case \"Moving\":\r\n                        //init movement\r\n                        if(!brainN.isMoving){\r\n                            brainN.movement.distanceToPoint = getDistanceToPoint(update[i].x, update[i].y, brainN.movement.endX, brainN.movement.endY);\r\n                            let direction = getDirectionToPoint(update[i].x, update[i].y, brainN.movement.endX, brainN.movement.endY, brainN.movement.distanceToPoint);\r\n                            brainN.movement.directionX = direction.x;\r\n                            brainN.movement.directionY = direction.y;\r\n                            brainN.isMoving = true;                            \r\n                        }else{\r\n                            update[i].x = update[i].x + (brainN.movement.directionX * returnSurfaceObject(update[i].type).movementSpeed * secondsPassed); \r\n                            update[i].y = update[i].y + (brainN.movement.directionY * returnSurfaceObject(update[i].type).movementSpeed * secondsPassed);\r\n                        }\r\n                        \r\n                        if(Math.hypot(update[i].x - brainN.movement.startX, update[i].y - brainN.movement.startY) >= brainN.movement.distanceToPoint){\r\n                            //else get next point.\r\n                            //when point reached\r\n                            //if last point then set to done moving\r\n                            if(brainN.path.length === 0){\r\n                                brainN.isMoving = false;\r\n                                brainN.action = \"Reached Target\";\r\n                            }else{\r\n                                let nextPoint = brainN.path.shift();\r\n                            \r\n                                brainN.movement.endX = nextPoint.x;\r\n                                brainN.movement.endY = nextPoint.y;\r\n                                //recalculate movement for new point\r\n                                brainN.isMoving = false;\r\n                            }\r\n                            \r\n                                \r\n                        }\r\n\r\n                        break;\r\n                    case \"Dying\":\r\n                        update = removeFromArrayByIndex(update, i);\r\n                        brainUpdate = deleteBrainObjById(brainUpdate, update.id); \r\n                        break;\r\n                    case \"Hungry\":\r\n                        let bush = getClosestBush(update, update[i], brainN);\r\n                        if(bush === null){\r\n                            //stay hungry\r\n                        }else{\r\n                            let updatedData;\r\n                            //we need to check if start point is wall.\r\n                            //if it is then we need to find the closest point that is not a wall.\r\n                            //and change start point to that\r\n                            updatedData = initPathfinding(update[i], brainN, bush, mapCopy, update, grid);\r\n\r\n                            //no path found, set state to idle\r\n                            if(!updatedData){\r\n                                let nearbyValidPoint = getNearbyPointThatIsntWall(update[i].x, update[i].y);\r\n                                //reset surfaceObject to this x,y. will be so close usually that you cant tell.\r\n                                update[i].x = nearbyValidPoint.x;\r\n                                update[i].y = nearbyValidPoint.y;\r\n                                brainN.action = \"Idle\";\r\n                                break;\r\n                            }else{\r\n                                brainN.closestPoint = 0;\r\n                                brainN.counter = 0;\r\n                                //attach path details to object\r\n                                update[i] = updatedData.surfaceObject;\r\n                                brainN = updatedData.brain;\r\n            \r\n                                //set to moving, inits action\r\n                                brainN.action = \"Moving\";\r\n                                brainN.target = bush;\r\n                                brainN.targetAction = \"Eat\";\r\n                            }\r\n                        }\r\n                        break;\r\n                    case \"Eat Target\":\r\n                        //calculate new path\r\n                        //15 and 10 are bush size and rabbit size\r\n                        if(!(Math.hypot(update[i].x - brainN.target.x, update[i].y - brainN.target.y) <= (15 + 10))){\r\n                            let updatedData = initPathfinding(update[i], brainN, brainN.target, mapCopy, update, grid);\r\n                            //no path found, set state to idle\r\n                            if(!updatedData){\r\n                                brainN.action = \"Idle\";\r\n                            }else{\r\n                                //attach path details to object\r\n                                update[i] = updatedData.surfaceObject;\r\n                                brainN = updatedData.brain;\r\n            \r\n                                //set to moving, inits action\r\n                                brainN.action = \"Moving\";\r\n                                brainN.targetAction = \"Eat\";\r\n                            }\r\n                        }else{\r\n                            //decrease food & hunger by 1\r\n                            for(let z = 0; z < update.length; z++){\r\n                                if(update[z].id === brainN.target.id){\r\n                                    updateFood(update[z], -2);\r\n                                    updateHunger(update[i], 1);\r\n                                }\r\n                            }\r\n                            break;\r\n                        }\r\n                        \r\n                    \r\n                }     \r\n\r\n            }\r\n        }\r\n    }\r\n    return {surfaceObjects: update, brain: brainUpdate};\r\n}","import { returnSurfaceObject } from '../../data/map/surfaceObjects';\r\n\r\n//takes a surface object and a health modifier amount and returns the object with the property changed\r\nexport function updateHealth(obj, amount){\r\n    obj.health = obj.health + amount;\r\n\r\n    if(obj.health >= returnSurfaceObject(obj.type).maxHealth){\r\n        obj.health = returnSurfaceObject(obj.type).maxHealth;\r\n    }\r\n\r\n    if(obj.health <= 0){\r\n        obj.health = 0;\r\n    }\r\n\r\n    return obj;\r\n}","export function getBrainObjectById(id, brain){\r\n    let brainCopy = [...brain];\r\n    let brainObjCopy = false;\r\n\r\n    for(let i = 0; i < brainCopy.length; i++){\r\n        if(brainCopy[i].surfaceObjectId === id){\r\n            brainObjCopy = brainCopy[i];\r\n        }    \r\n    }\r\n\r\n    return brainObjCopy;\r\n}\r\n\r\nexport function deleteBrainObjById(arr, id){\r\n    let brainCopy = arr;\r\n    let index = 0;\r\n\r\n    for(let i = 0; i < brainCopy.length; i++){\r\n        if(brainCopy[i].surfaceObjectId === id){\r\n            index = i;\r\n        }    \r\n    }\r\n    \r\n    brainCopy.splice(index, 1); \r\n\r\n    return brainCopy;\r\n}","import React, { useState } from 'react';\r\nimport Map from '../Map/Map';\r\nimport { updateSurfaceObjects } from '../../Simulation Logic/update'; \r\n\r\nimport './styles.css';\r\nimport { getGrid } from '../../Simulation Logic/grid';\r\n\r\nfunction Simulation() {\r\n\r\n    const [map, setMap] = useState([]);\r\n    const [surfaceObjects, setSurfaceObjects] = useState([]);\r\n    const [isLoaded, setIsLoaded] = useState(false);\r\n    const [started, setStarted] = useState(false);\r\n    const [requestAnimationFrameID, setRequestAnimationFrameID] = useState(undefined); \r\n    const [brain, setBrain] = useState([]);\r\n    const [selectedMapSaveNumber, setSelectedMapSaveNumber] = useState(0);\r\n\r\n    let secondsPassed = 0;\r\n    let oldTimeStamp = 0;\r\n\r\n    function mapLoaded(){\r\n        setIsLoaded(true);\r\n    }\r\n\r\n    function loadMapClicked(mapSaveNumber){\r\n        setSelectedMapSaveNumber(mapSaveNumber);\r\n\r\n        let mapData = window.localStorage.getItem(`map${mapSaveNumber}`);\r\n        let data = JSON.parse(mapData);\r\n        setMap(map => (data.mapData));\r\n        setSurfaceObjects(surfaceObjects => (data.surfaceData));\r\n\r\n        let aiData = JSON.parse(window.localStorage.getItem(`map${mapSaveNumber}Ai`));\r\n        setBrain(aiData);\r\n        mapLoaded();\r\n    }\r\n\r\n    function deleteMapClicked(mapSaveNumber){\r\n        if(window.confirm(`Are you sure you want to delete save #${mapSaveNumber}`)) {\r\n            localStorage.removeItem(`map${mapSaveNumber}`);\r\n            localStorage.removeItem(`map${mapSaveNumber}Ai`);\r\n            window.location.reload();\r\n          }\r\n    }\r\n\r\n    function startClicked(){\r\n\r\n        setStarted(!started);\r\n\r\n        if(started){\r\n            stopLoop();\r\n        }\r\n        if(!started){\r\n            startLoop();\r\n        }\r\n        \r\n       \r\n    }\r\n\r\n    function startLoop(){\r\n        if(!requestAnimationFrameID){\r\n            setRequestAnimationFrameID(window.requestAnimationFrame(gameLoop));\r\n        }\r\n    }\r\n\r\n    function stopLoop(){\r\n        if (requestAnimationFrameID) {\r\n            window.cancelAnimationFrame(requestAnimationFrameID);\r\n            setRequestAnimationFrameID(undefined);\r\n         }\r\n    }\r\n\r\n    function update(secondsPassed){\r\n\r\n        let update = updateSurfaceObjects(secondsPassed, map, surfaceObjects, brain, map, getGrid(map, surfaceObjects))\r\n        setBrain(brain => (update.brain));\r\n        setSurfaceObjects(surfaceObjects => (update.surfaceObjects));\r\n\r\n    }\r\n\r\n    function gameLoop(timeStamp){\r\n        setRequestAnimationFrameID(undefined);\r\n\r\n        //we can slow down time or speed up this time by multiplying it by a modifier\r\n        let seconds = (timeStamp - oldTimeStamp) / 1000;\r\n\r\n        //global vars defined at top, not state vars\r\n        secondsPassed = seconds;\r\n\r\n        //limit time skip on pause/start\r\n        secondsPassed = Math.min(secondsPassed, 0.1);\r\n        oldTimeStamp = timeStamp;\r\n\r\n        //\r\n        \r\n        update(secondsPassed);\r\n        \r\n        //\r\n\r\n        startLoop();\r\n\r\n    }\r\n    \r\n    function loadLocalSaves(){\r\n\r\n        //this is the amount of saves we are supporting right now\r\n        const numbers = [1, 2, 3, 4, 5];\r\n\r\n        return numbers.map((number) => \r\n            <div key={number} className=\"saveBar\">\r\n                \r\n                <p className=\"mapSaveFileText\">Map {number}</p>\r\n\r\n                {localStorage.hasOwnProperty(`map${number}`) ? (\r\n                    <div className=\"saveControls\">\r\n                        <input type=\"button\" className=\"navBtn inputButtonNoBorder\" value=\"Load\" onClick={() => loadMapClicked(number)}></input>\r\n                        <input type=\"button\" className=\"navBtn inputButtonNoBorder\" value=\"Delete\" onClick={() => deleteMapClicked(number)}></input>\r\n                    </div>\r\n                ) \r\n                :\r\n                (\r\n                    <p className=\"mapFileSupportingText\">does not exist.</p>\r\n                )}\r\n\r\n            </div>\r\n\r\n                \r\n            \r\n        );\r\n    }\r\n\r\n    function backClicked(){\r\n        setIsLoaded(false);\r\n        //pause\r\n        if(started){\r\n            startClicked();\r\n        }\r\n    }\r\n\r\n    return(\r\n        <div className=\"Simulation\">\r\n            {!isLoaded ? (\r\n                <div className=\"loading\">\r\n\r\n                    <div className=\"loadPreset\">\r\n                        <p className={\"mapSaveFileText centeredText\"}>Simulation</p>\r\n                        {loadLocalSaves()}\r\n                    </div>\r\n                    \r\n                </div>\r\n            ) : (\r\n                <>\r\n                    <Map map={map}\r\n                         surfaceObjects={surfaceObjects}\r\n                         startClicked={startClicked}\r\n                         started={started}\r\n                         isEditor={false}\r\n                         brain={brain}\r\n                         backClicked={backClicked}\r\n                         selectedMapSaveNumber={selectedMapSaveNumber}\r\n                    />\r\n                    \r\n                </>\r\n            )}\r\n\r\n            \r\n        </div>\r\n    );\r\n\r\n}\r\n\r\nexport default Simulation;\r\n","export const Map1 = {\"mapData\":[[{\"x\":0,\"y\":0,\"type\":\"grass\"},{\"x\":0,\"y\":1,\"type\":\"grass\"},{\"x\":0,\"y\":2,\"type\":\"grass\"},{\"x\":0,\"y\":3,\"type\":\"grass\"},{\"x\":0,\"y\":4,\"type\":\"grass\"}],[{\"x\":1,\"y\":0,\"type\":\"grass\"},{\"x\":1,\"y\":1,\"type\":\"grass\"},{\"x\":1,\"y\":2,\"type\":\"grass\"},{\"x\":1,\"y\":3,\"type\":\"grass\"},{\"x\":1,\"y\":4,\"type\":\"grass\"}],[{\"x\":2,\"y\":0,\"type\":\"grass\"},{\"x\":2,\"y\":1,\"type\":\"grass\"},{\"x\":2,\"y\":2,\"type\":\"grass\"},{\"x\":2,\"y\":3,\"type\":\"grass\"},{\"x\":2,\"y\":4,\"type\":\"grass\"}],[{\"x\":3,\"y\":0,\"type\":\"grass\"},{\"x\":3,\"y\":1,\"type\":\"grass\"},{\"x\":3,\"y\":2,\"type\":\"grass\"},{\"x\":3,\"y\":3,\"type\":\"grass\"},{\"x\":3,\"y\":4,\"type\":\"grass\"}],[{\"x\":4,\"y\":0,\"type\":\"grass\"},{\"x\":4,\"y\":1,\"type\":\"grass\"},{\"x\":4,\"y\":2,\"type\":\"grass\"},{\"x\":4,\"y\":3,\"type\":\"grass\"},{\"x\":4,\"y\":4,\"type\":\"grass\"}]],\"surfaceData\":[{\"x\":444,\"y\":57,\"health\":40,\"hunger\":100,\"type\":\"rabbit\",\"id\":0},{\"x\":161,\"y\":458,\"health\":40,\"hunger\":100,\"type\":\"rabbit\",\"id\":1},{\"x\":149,\"y\":33,\"type\":\"tree\",\"id\":2},{\"x\":367,\"y\":171,\"type\":\"tree\",\"id\":3},{\"x\":46,\"y\":377,\"type\":\"tree\",\"id\":4},{\"x\":404,\"y\":413,\"type\":\"tree\",\"id\":5},{\"x\":87,\"y\":189,\"food\":100,\"type\":\"bush\",\"id\":6},{\"x\":303,\"y\":315,\"food\":100,\"type\":\"bush\",\"id\":7}]};\r\nexport const Map2 = {\"mapData\":[[{\"x\":0,\"y\":0,\"type\":\"grass\"},{\"x\":0,\"y\":1,\"type\":\"grass\"},{\"x\":0,\"y\":2,\"type\":\"grass\"},{\"x\":0,\"y\":3,\"type\":\"grass\"},{\"x\":0,\"y\":4,\"type\":\"grass\"},{\"x\":0,\"y\":5,\"type\":\"grass\"}],[{\"x\":1,\"y\":0,\"type\":\"grass\"},{\"x\":1,\"y\":1,\"type\":\"grass\"},{\"x\":1,\"y\":2,\"type\":\"grass\"},{\"x\":1,\"y\":3,\"type\":\"grass\"},{\"x\":1,\"y\":4,\"type\":\"grass\"},{\"x\":1,\"y\":5,\"type\":\"grass\"}],[{\"x\":2,\"y\":0,\"type\":\"grass\"},{\"x\":2,\"y\":1,\"type\":\"grass\"},{\"x\":2,\"y\":2,\"type\":\"grass\"},{\"x\":2,\"y\":3,\"type\":\"grass\"},{\"x\":2,\"y\":4,\"type\":\"grass\"},{\"x\":2,\"y\":5,\"type\":\"grass\"}],[{\"x\":3,\"y\":0,\"type\":\"grass\"},{\"x\":3,\"y\":1,\"type\":\"grass\"},{\"x\":3,\"y\":2,\"type\":\"grass\"},{\"x\":3,\"y\":3,\"type\":\"grass\"},{\"x\":3,\"y\":4,\"type\":\"grass\"},{\"x\":3,\"y\":5,\"type\":\"grass\"}],[{\"x\":4,\"y\":0,\"type\":\"grass\"},{\"x\":4,\"y\":1,\"type\":\"grass\"},{\"x\":4,\"y\":2,\"type\":\"grass\"},{\"x\":4,\"y\":3,\"type\":\"grass\"},{\"x\":4,\"y\":4,\"type\":\"grass\"},{\"x\":4,\"y\":5,\"type\":\"grass\"}],[{\"x\":5,\"y\":0,\"type\":\"grass\"},{\"x\":5,\"y\":1,\"type\":\"grass\"},{\"x\":5,\"y\":2,\"type\":\"grass\"},{\"x\":5,\"y\":3,\"type\":\"grass\"},{\"x\":5,\"y\":4,\"type\":\"grass\"},{\"x\":5,\"y\":5,\"type\":\"grass\"}]],\"surfaceData\":[{\"x\":234,\"y\":33,\"type\":\"tree\",\"id\":0},{\"x\":100,\"y\":213,\"type\":\"tree\",\"id\":1},{\"x\":375,\"y\":183,\"type\":\"tree\",\"id\":2},{\"x\":145,\"y\":491,\"type\":\"tree\",\"id\":3},{\"x\":534,\"y\":71,\"type\":\"tree\",\"id\":4},{\"x\":470,\"y\":394,\"type\":\"tree\",\"id\":5},{\"x\":79,\"y\":68,\"health\":40,\"hunger\":100,\"type\":\"rabbit\",\"id\":6},{\"x\":480,\"y\":45,\"health\":40,\"hunger\":100,\"type\":\"rabbit\",\"id\":7},{\"x\":159,\"y\":331,\"health\":40,\"hunger\":100,\"type\":\"rabbit\",\"id\":8},{\"x\":546,\"y\":185,\"health\":40,\"hunger\":100,\"type\":\"rabbit\",\"id\":9},{\"x\":436,\"y\":535,\"health\":40,\"hunger\":100,\"type\":\"rabbit\",\"id\":10},{\"x\":252,\"y\":261,\"food\":100,\"type\":\"bush\",\"id\":11},{\"x\":318,\"y\":441,\"food\":100,\"type\":\"bush\",\"id\":12}]};\r\nexport const Map1Ai = [{\"surfaceObjectId\":0,\"isMoving\":false,\"action\":\"Idle\",\"movement\":{\"distanceToPoint\":\"\",\"directionX\":\"\",\"directionY\":\"\",\"startX\":0,\"startY\":0,\"endX\":0,\"endY\":0}},{\"surfaceObjectId\":1,\"isMoving\":false,\"action\":\"Idle\",\"movement\":{\"distanceToPoint\":\"\",\"directionX\":\"\",\"directionY\":\"\",\"startX\":0,\"startY\":0,\"endX\":0,\"endY\":0}},{\"surfaceObjectId\":2,\"isMoving\":false,\"action\":\"Idle\",\"movement\":{\"distanceToPoint\":\"\",\"directionX\":\"\",\"directionY\":\"\",\"startX\":0,\"startY\":0,\"endX\":0,\"endY\":0}},{\"surfaceObjectId\":3,\"isMoving\":false,\"action\":\"Idle\",\"movement\":{\"distanceToPoint\":\"\",\"directionX\":\"\",\"directionY\":\"\",\"startX\":0,\"startY\":0,\"endX\":0,\"endY\":0}},{\"surfaceObjectId\":4,\"isMoving\":false,\"action\":\"Idle\",\"movement\":{\"distanceToPoint\":\"\",\"directionX\":\"\",\"directionY\":\"\",\"startX\":0,\"startY\":0,\"endX\":0,\"endY\":0}},{\"surfaceObjectId\":5,\"isMoving\":false,\"action\":\"Idle\",\"movement\":{\"distanceToPoint\":\"\",\"directionX\":\"\",\"directionY\":\"\",\"startX\":0,\"startY\":0,\"endX\":0,\"endY\":0}},{\"surfaceObjectId\":6,\"isMoving\":false,\"action\":\"Idle\",\"movement\":{\"distanceToPoint\":\"\",\"directionX\":\"\",\"directionY\":\"\",\"startX\":0,\"startY\":0,\"endX\":0,\"endY\":0}},{\"surfaceObjectId\":7,\"isMoving\":false,\"action\":\"Idle\",\"movement\":{\"distanceToPoint\":\"\",\"directionX\":\"\",\"directionY\":\"\",\"startX\":0,\"startY\":0,\"endX\":0,\"endY\":0}}];\r\nexport const Map2Ai = [{\"surfaceObjectId\":0,\"isMoving\":false,\"action\":\"Idle\",\"movement\":{\"distanceToPoint\":\"\",\"directionX\":\"\",\"directionY\":\"\",\"startX\":0,\"startY\":0,\"endX\":0,\"endY\":0}},{\"surfaceObjectId\":1,\"isMoving\":false,\"action\":\"Idle\",\"movement\":{\"distanceToPoint\":\"\",\"directionX\":\"\",\"directionY\":\"\",\"startX\":0,\"startY\":0,\"endX\":0,\"endY\":0}},{\"surfaceObjectId\":2,\"isMoving\":false,\"action\":\"Idle\",\"movement\":{\"distanceToPoint\":\"\",\"directionX\":\"\",\"directionY\":\"\",\"startX\":0,\"startY\":0,\"endX\":0,\"endY\":0}},{\"surfaceObjectId\":3,\"isMoving\":false,\"action\":\"Idle\",\"movement\":{\"distanceToPoint\":\"\",\"directionX\":\"\",\"directionY\":\"\",\"startX\":0,\"startY\":0,\"endX\":0,\"endY\":0}},{\"surfaceObjectId\":4,\"isMoving\":false,\"action\":\"Idle\",\"movement\":{\"distanceToPoint\":\"\",\"directionX\":\"\",\"directionY\":\"\",\"startX\":0,\"startY\":0,\"endX\":0,\"endY\":0}},{\"surfaceObjectId\":5,\"isMoving\":false,\"action\":\"Idle\",\"movement\":{\"distanceToPoint\":\"\",\"directionX\":\"\",\"directionY\":\"\",\"startX\":0,\"startY\":0,\"endX\":0,\"endY\":0}},{\"surfaceObjectId\":6,\"isMoving\":false,\"action\":\"Idle\",\"movement\":{\"distanceToPoint\":\"\",\"directionX\":\"\",\"directionY\":\"\",\"startX\":0,\"startY\":0,\"endX\":0,\"endY\":0}},{\"surfaceObjectId\":7,\"isMoving\":false,\"action\":\"Idle\",\"movement\":{\"distanceToPoint\":\"\",\"directionX\":\"\",\"directionY\":\"\",\"startX\":0,\"startY\":0,\"endX\":0,\"endY\":0}},{\"surfaceObjectId\":8,\"isMoving\":false,\"action\":\"Idle\",\"movement\":{\"distanceToPoint\":\"\",\"directionX\":\"\",\"directionY\":\"\",\"startX\":0,\"startY\":0,\"endX\":0,\"endY\":0}},{\"surfaceObjectId\":9,\"isMoving\":false,\"action\":\"Idle\",\"movement\":{\"distanceToPoint\":\"\",\"directionX\":\"\",\"directionY\":\"\",\"startX\":0,\"startY\":0,\"endX\":0,\"endY\":0}},{\"surfaceObjectId\":10,\"isMoving\":false,\"action\":\"Idle\",\"movement\":{\"distanceToPoint\":\"\",\"directionX\":\"\",\"directionY\":\"\",\"startX\":0,\"startY\":0,\"endX\":0,\"endY\":0}},{\"surfaceObjectId\":11,\"isMoving\":false,\"action\":\"Idle\",\"movement\":{\"distanceToPoint\":\"\",\"directionX\":\"\",\"directionY\":\"\",\"startX\":0,\"startY\":0,\"endX\":0,\"endY\":0}},{\"surfaceObjectId\":12,\"isMoving\":false,\"action\":\"Idle\",\"movement\":{\"distanceToPoint\":\"\",\"directionX\":\"\",\"directionY\":\"\",\"startX\":0,\"startY\":0,\"endX\":0,\"endY\":0}}];\r\n","import React, { useState, useEffect } from 'react';\nimport './App.css';\nimport MapEditor from './components/Map/MapEditor';\nimport Simulation from './components/Simulation/Simulation';\nimport { Map1, Map1Ai, Map2, Map2Ai } from './data/map/map1preset';\n\nimport {\n  BrowserRouter as Router,\n  Switch,\n  Route,\n  Link\n} from \"react-router-dom\";\n\n\nfunction App() {\n\n  const [selectedNavItem, setSelectedNavItem] = useState('');\n\n  useEffect(() => {\n    const pathname = window.location.pathname\n    if (pathname.toString().toLowerCase() === '/editor') {\n      setSelectedNavItem('editor');\n    }\n    if (pathname.toString().toLowerCase() === '/simulation' || pathname.toString().toLowerCase() === '/') {\n      setSelectedNavItem('simulation');\n    }\n\n    //check if its the first time the user has been on\n    if(!localStorage.hasOwnProperty(`newUser`)){\n      localStorage.setItem('newUser', true);\n      //get map data and brain from file\n      localStorage.setItem('map1', JSON.stringify(Map1));\n      localStorage.setItem('map1Ai', JSON.stringify(Map1Ai));\n      localStorage.setItem('map2', JSON.stringify(Map2));\n      localStorage.setItem('map2Ai', JSON.stringify(Map2Ai));\n      //set map and brain data to map1 from local storage\n    }\n\n  }, []);\n\n  \n\n\n\n\n  function navButtonClicked(routeName) {\n    setSelectedNavItem(routeName);\n  }\n\n  return (\n    <div className=\"App\">\n      <Router>\n        <div>\n          <nav className=\"navBar\">\n            <p className=\"navItem\">Terra</p>\n            <Link className={\"navItem navBtn\" + (selectedNavItem === 'simulation' ? ' selectedButtonNoBorder' : ' ')} to=\"/Simulation\"\n              onClick={() => navButtonClicked('simulation')}>Simulation</Link>\n            <Link className={\"navItem navBtn\" + (selectedNavItem === 'editor' ? ' selectedButtonNoBorder' : ' ')} to=\"/Editor\"\n              onClick={() => navButtonClicked('editor')}>Editor</Link>\n          </nav>\n          <Switch>\n            <Route path=\"/simulation\">\n              <Simulation />\n            </Route>\n            <Route path=\"/editor\">\n              <MapEditor />\n            </Route>\n            <Route path=\"/\" >\n              <Simulation />\n            </Route>\n\n          </Switch>\n        </div>\n      </Router>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n\n"],"sourceRoot":""}